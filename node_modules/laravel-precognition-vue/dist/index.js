import { client, createValidator, toSimpleValidationErrors } from 'laravel-precognition';
import { reactive, ref, toRaw } from 'vue';
import cloneDeep from 'lodash.clonedeep';
import get from 'lodash.get';
import { resolveName } from 'laravel-precognition';
import set from 'lodash.set';
export const useForm = (method, url, inputs, config = {}) => {
    // @ts-expect-error
    method = method.toLowerCase();
    /**
     * The original data.
     */
    const originalData = cloneDeep(inputs);
    /**
     * The original input names.
     */
    const originalInputs = Object.keys(originalData);
    /**
     * Reactive valid state.
     */
    const valid = ref([]);
    /**
     * Reactive touched state.
     */
    const touched = ref([]);
    /**
     * The validator instance.
     */
    const validator = createValidator(client => client[method](url, form.data(), config), originalData)
        .on('validatingChanged', () => {
        form.validating = validator.validating();
    })
        .on('touchedChanged', () => {
        // @ts-expect-error
        touched.value = validator.touched();
        // @ts-expect-error
        valid.value = validator.valid();
    })
        .on('errorsChanged', () => {
        form.hasErrors = validator.hasErrors();
        // @ts-expect-error
        valid.value = validator.valid();
        // @ts-expect-error
        form.errors = toSimpleValidationErrors(validator.errors());
    });
    /**
     * Resolve the config for a form submission.
     */
    const resolveSubmitConfig = (config) => ({
        ...config,
        precognitive: false,
        onStart: () => {
            form.processing = true;
            (config.onStart ?? (() => null))();
        },
        onFinish: () => {
            form.processing = false;
            (config.onFinish ?? (() => null))();
        },
        onValidationError: (response, error) => {
            validator.setErrors(response.data.errors);
            return config.onValidationError
                ? config.onValidationError(response)
                : Promise.reject(error);
        },
    });
    /**
     * Create a new form instance.
     */
    const createForm = () => ({
        ...cloneDeep(originalData),
        data() {
            const data = cloneDeep(toRaw(form));
            return originalInputs.reduce((carry, name) => ({
                ...carry,
                [name]: data[name],
            }), {});
        },
        setData(data) {
            Object.keys(data).forEach(input => {
                this[input] = data[input];
            });
            return form;
        },
        touched(name) {
            // @ts-expect-error
            return touched.value.includes(name);
        },
        validate(name) {
            // @ts-expect-error
            name = resolveName(name);
            validator.validate(name, get(this.data(), name));
            return form;
        },
        validating: false,
        valid(name) {
            // @ts-expect-error
            return valid.value.includes(name);
        },
        invalid(name) {
            return typeof form.errors[name] !== 'undefined';
        },
        errors: {},
        hasErrors: false,
        setErrors(errors) {
            // @ts-expect-error
            validator.setErrors(errors);
            return form;
        },
        forgetError(name) {
            // @ts-expect-error
            validator.forgetError(name);
            return form;
        },
        reset(...names) {
            const original = cloneDeep(originalData);
            if (names.length === 0) {
                // @ts-expect-error
                originalInputs.forEach(name => (form[name] = original[name]));
            }
            else {
                names.forEach(name => set(form, name, get(original, name)));
            }
            // @ts-expect-error
            validator.reset(...names);
            return form;
        },
        setValidationTimeout(duration) {
            validator.setTimeout(duration);
            return form;
        },
        processing: false,
        async submit(config = {}) {
            return client[method](url, form.data(), resolveSubmitConfig(config));
        },
        validateFiles() {
            validator.validateFiles();
            return form;
        },
        validator() {
            return validator;
        },
    });
    /**
     * The form instance.
     */
    const form = reactive(createForm());
    return form;
};
